var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Copyright (c) 2015 Uber Technologies, Inc.

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window, document, process */
import PropTypes from 'prop-types';

var isBrowser = !((typeof process === 'undefined' ? 'undefined' : _typeof(process)) === 'object' && String(process) === '[object process]' && !process.browser);

var mapboxgl = isBrowser ? require('mapbox-gl') : null;

function noop() {}

var propTypes = {
  // Creation parameters
  container: PropTypes.object, /** The container to have the map. */
  mapboxApiAccessToken: PropTypes.string, /** Mapbox API access token for Mapbox tiles/styles. */
  attributionControl: PropTypes.bool, /** Show attribution control or not. */
  preserveDrawingBuffer: PropTypes.bool, /** Useful when you want to export the canvas as a PNG. */
  onLoad: PropTypes.func, /** The onLoad callback for the map */
  onError: PropTypes.func, /** The onError callback for the map */
  reuseMaps: PropTypes.bool,
  reuseMap: PropTypes.bool,
  transformRequest: PropTypes.func, /** The transformRequest callback for the map */

  mapStyle: PropTypes.string, /** The Mapbox style. A string url to a MapboxGL style */
  visible: PropTypes.bool, /** Whether the map is visible */

  // Map view state
  width: PropTypes.number.isRequired, /** The width of the map. */
  height: PropTypes.number.isRequired, /** The height of the map. */
  longitude: PropTypes.number.isRequired, /** The longitude of the center of the map. */
  latitude: PropTypes.number.isRequired, /** The latitude of the center of the map. */
  zoom: PropTypes.number.isRequired, /** The tile zoom level of the map. */
  bearing: PropTypes.number, /** Specify the bearing of the viewport */
  pitch: PropTypes.number, /** Specify the pitch of the viewport */

  // Note: Non-public API, see https://github.com/mapbox/mapbox-gl-js/issues/1137
  altitude: PropTypes.number /** Altitude of the viewport camera. Default 1.5 "screen heights" */
};

var defaultProps = {
  mapboxApiAccessToken: getAccessToken(),
  preserveDrawingBuffer: false,
  attributionControl: true,
  preventStyleDiffing: false,
  onLoad: noop,
  onError: noop,
  reuseMaps: false,
  reuseMap: false,
  transformRequest: null,

  mapStyle: 'mapbox://styles/mapbox/light-v8',
  visible: true,

  bearing: 0,
  pitch: 0,
  altitude: 1.5
};

// Try to get access token from URL, env, local storage or config
export function getAccessToken() {
  var accessToken = null;

  if (typeof window !== 'undefined' && window.location) {
    var match = window.location.search.match(/access_token=([^&\/]*)/);
    accessToken = match && match[1];
  }

  if (!accessToken && typeof process !== 'undefined') {
    // Note: This depends on bundler plugins (e.g. webpack) inmporting environment correctly
    accessToken = accessToken || process.env.MapboxAccessToken; // eslint-disable-line
  }

  return accessToken || null;
}

// Helper function to merge defaultProps and check prop types
function checkPropTypes(props) {
  var component = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'component';

  // TODO - check for production (unless done by prop types package?)
  if (props.debug) {
    PropTypes.checkPropTypes(propTypes, props, 'prop', component);
  }
}

// A small wrapper class for mapbox-gl
// - Provides a prop style interface (that can be trivially used by a React wrapper)
// - Makes sure mapbox doesn't crash under Node
// - Handles map reuse (to work around Mapbox resource leak issues)
// - Provides support for specifying tokens during development

var Mapbox = function () {
  _createClass(Mapbox, null, [{
    key: 'supported',
    value: function supported() {
      return mapboxgl && mapboxgl.supported();
    }
  }]);

  function Mapbox(props) {
    _classCallCheck(this, Mapbox);

    if (!mapboxgl) {
      throw new Error('Mapbox not supported');
    }

    if (!Mapbox.initialized && console.debug) {
      // eslint-disable-line
      Mapbox.initialized = true;
      console.debug('react-map-gl: using mapbox-gl v' + mapboxgl.version); // eslint-disable-line
    }

    this.props = {};
    this._initialize(props);
  }

  _createClass(Mapbox, [{
    key: 'finalize',
    value: function finalize() {
      if (!mapboxgl || !this._map) {
        return this;
      }

      this._destroy();
      return this;
    }
  }, {
    key: 'setProps',
    value: function setProps(props) {
      if (!mapboxgl || !this._map) {
        return this;
      }

      this._update(this.props, props);
      return this;
    }

    // Mapbox's map.resize() reads size from DOM, so DOM element must already be resized
    // In a system like React we must wait to read size until after render
    // (e.g. until "componentDidUpdate")

  }, {
    key: 'resize',
    value: function resize() {
      if (!mapboxgl || !this._map) {
        return this;
      }

      this._map.resize();
      return this;
    }

    // External apps can access map this way

  }, {
    key: 'getMap',
    value: function getMap() {
      return this._map;
    }

    // PRIVATE API

  }, {
    key: '_create',
    value: function _create(props) {
      // Reuse a saved map, if available
      if ((props.reuseMaps || props.reuseMap) && Mapbox.savedMap) {
        this._map = this.map = Mapbox.savedMap;
        // When reusing the saved map, we need to reparent the map(canvas) and other child nodes
        // intoto the new container from the props.
        // Step1: reparenting child nodes from old container to new container
        var oldContainer = this._map.getContainer();
        var newContainer = props.container;
        newContainer.classList.add('mapboxgl-map');
        while (oldContainer.childNodes.length > 0) {
          newContainer.appendChild(oldContainer.childNodes[0]);
        }
        // Step2: replace the internal container with new container from the react component
        this._map._container = newContainer;
        Mapbox.savedMap = null;

        // Update style
        if (props.mapStyle) {
          this._map.setStyle(props.mapStyle);
        }

        // TODO - need to call onload again, need to track with Promise?
        props.onLoad();
      } else {
        var mapOptions = {
          container: props.container || document.body,
          center: [props.longitude, props.latitude],
          zoom: props.zoom,
          pitch: props.pitch,
          bearing: props.bearing,
          style: props.mapStyle,
          interactive: false,
          attributionControl: props.attributionControl,
          preserveDrawingBuffer: props.preserveDrawingBuffer
        };
        // We don't want to pass a null or no-op transformRequest function.
        if (props.transformRequest) {
          mapOptions.transformRequest = props.transformRequest;
        }
        this._map = this.map = new mapboxgl.Map(mapOptions);
        // Attach optional onLoad function
        this.map.once('load', props.onLoad);
        this.map.on('error', props.onError);
      }

      return this;
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      if (!Mapbox.savedMap) {
        Mapbox.savedMap = this._map;
      } else {
        this._map.remove();
      }
    }
  }, {
    key: '_initialize',
    value: function _initialize(props) {
      props = Object.assign({}, defaultProps, props);
      checkPropTypes(props, 'Mapbox');

      // Make empty string pick up default prop
      this.accessToken = props.mapboxApiAccessToken || defaultProps.mapboxApiAccessToken;

      // Creation only props
      if (mapboxgl) {
        if (!this.accessToken) {
          mapboxgl.accessToken = 'no-token'; // Prevents mapbox from throwing
        } else {
          mapboxgl.accessToken = this.accessToken;
        }
      }

      this._create(props);

      // Disable outline style
      var canvas = this.map.getCanvas();
      if (canvas) {
        canvas.style.outline = 'none';
      }

      this._updateMapViewport({}, props);
      this._updateMapSize({}, props);

      this.props = props;
    }
  }, {
    key: '_update',
    value: function _update(oldProps, newProps) {
      newProps = Object.assign({}, this.props, newProps);
      checkPropTypes(newProps, 'Mapbox');

      this._updateMapViewport(oldProps, newProps);
      this._updateMapSize(oldProps, newProps);

      this.props = newProps;
    }
  }, {
    key: '_updateMapViewport',
    value: function _updateMapViewport(oldProps, newProps) {
      var viewportChanged = newProps.latitude !== oldProps.latitude || newProps.longitude !== oldProps.longitude || newProps.zoom !== oldProps.zoom || newProps.pitch !== oldProps.pitch || newProps.bearing !== oldProps.bearing || newProps.altitude !== oldProps.altitude;

      if (viewportChanged) {
        this._map.jumpTo({
          center: [newProps.longitude, newProps.latitude],
          zoom: newProps.zoom,
          bearing: newProps.bearing,
          pitch: newProps.pitch
        });

        // TODO - jumpTo doesn't handle altitude
        if (newProps.altitude !== oldProps.altitude) {
          this._map.transform.altitude = newProps.altitude;
        }
      }
    }

    // Note: needs to be called after render (e.g. in componentDidUpdate)

  }, {
    key: '_updateMapSize',
    value: function _updateMapSize(oldProps, newProps) {
      var sizeChanged = oldProps.width !== newProps.width || oldProps.height !== newProps.height;
      if (sizeChanged) {
        this._map.resize();
      }
    }
  }]);

  return Mapbox;
}();

export default Mapbox;


Mapbox.propTypes = propTypes;
Mapbox.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tYXBib3gvbWFwYm94LmpzIl0sIm5hbWVzIjpbIlByb3BUeXBlcyIsImlzQnJvd3NlciIsInByb2Nlc3MiLCJTdHJpbmciLCJicm93c2VyIiwibWFwYm94Z2wiLCJyZXF1aXJlIiwibm9vcCIsInByb3BUeXBlcyIsImNvbnRhaW5lciIsIm9iamVjdCIsIm1hcGJveEFwaUFjY2Vzc1Rva2VuIiwic3RyaW5nIiwiYXR0cmlidXRpb25Db250cm9sIiwiYm9vbCIsInByZXNlcnZlRHJhd2luZ0J1ZmZlciIsIm9uTG9hZCIsImZ1bmMiLCJvbkVycm9yIiwicmV1c2VNYXBzIiwicmV1c2VNYXAiLCJ0cmFuc2Zvcm1SZXF1ZXN0IiwibWFwU3R5bGUiLCJ2aXNpYmxlIiwid2lkdGgiLCJudW1iZXIiLCJpc1JlcXVpcmVkIiwiaGVpZ2h0IiwibG9uZ2l0dWRlIiwibGF0aXR1ZGUiLCJ6b29tIiwiYmVhcmluZyIsInBpdGNoIiwiYWx0aXR1ZGUiLCJkZWZhdWx0UHJvcHMiLCJnZXRBY2Nlc3NUb2tlbiIsInByZXZlbnRTdHlsZURpZmZpbmciLCJhY2Nlc3NUb2tlbiIsIndpbmRvdyIsImxvY2F0aW9uIiwibWF0Y2giLCJzZWFyY2giLCJlbnYiLCJNYXBib3hBY2Nlc3NUb2tlbiIsImNoZWNrUHJvcFR5cGVzIiwicHJvcHMiLCJjb21wb25lbnQiLCJkZWJ1ZyIsIk1hcGJveCIsInN1cHBvcnRlZCIsIkVycm9yIiwiaW5pdGlhbGl6ZWQiLCJjb25zb2xlIiwidmVyc2lvbiIsIl9pbml0aWFsaXplIiwiX21hcCIsIl9kZXN0cm95IiwiX3VwZGF0ZSIsInJlc2l6ZSIsInNhdmVkTWFwIiwibWFwIiwib2xkQ29udGFpbmVyIiwiZ2V0Q29udGFpbmVyIiwibmV3Q29udGFpbmVyIiwiY2xhc3NMaXN0IiwiYWRkIiwiY2hpbGROb2RlcyIsImxlbmd0aCIsImFwcGVuZENoaWxkIiwiX2NvbnRhaW5lciIsInNldFN0eWxlIiwibWFwT3B0aW9ucyIsImRvY3VtZW50IiwiYm9keSIsImNlbnRlciIsInN0eWxlIiwiaW50ZXJhY3RpdmUiLCJNYXAiLCJvbmNlIiwib24iLCJyZW1vdmUiLCJPYmplY3QiLCJhc3NpZ24iLCJfY3JlYXRlIiwiY2FudmFzIiwiZ2V0Q2FudmFzIiwib3V0bGluZSIsIl91cGRhdGVNYXBWaWV3cG9ydCIsIl91cGRhdGVNYXBTaXplIiwib2xkUHJvcHMiLCJuZXdQcm9wcyIsInZpZXdwb3J0Q2hhbmdlZCIsImp1bXBUbyIsInRyYW5zZm9ybSIsInNpemVDaGFuZ2VkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU9BLFNBQVAsTUFBc0IsWUFBdEI7O0FBRUEsSUFBTUMsWUFBWSxFQUNoQixRQUFPQyxPQUFQLHlDQUFPQSxPQUFQLE9BQW1CLFFBQW5CLElBQ0FDLE9BQU9ELE9BQVAsTUFBb0Isa0JBRHBCLElBRUEsQ0FBQ0EsUUFBUUUsT0FITyxDQUFsQjs7QUFNQSxJQUFNQyxXQUFXSixZQUFZSyxRQUFRLFdBQVIsQ0FBWixHQUFtQyxJQUFwRDs7QUFFQSxTQUFTQyxJQUFULEdBQWdCLENBQUU7O0FBRWxCLElBQU1DLFlBQVk7QUFDaEI7QUFDQUMsYUFBV1QsVUFBVVUsTUFGTCxFQUVhO0FBQzdCQyx3QkFBc0JYLFVBQVVZLE1BSGhCLEVBR3dCO0FBQ3hDQyxzQkFBb0JiLFVBQVVjLElBSmQsRUFJb0I7QUFDcENDLHlCQUF1QmYsVUFBVWMsSUFMakIsRUFLdUI7QUFDdkNFLFVBQVFoQixVQUFVaUIsSUFORixFQU1RO0FBQ3hCQyxXQUFTbEIsVUFBVWlCLElBUEgsRUFPUztBQUN6QkUsYUFBV25CLFVBQVVjLElBUkw7QUFTaEJNLFlBQVVwQixVQUFVYyxJQVRKO0FBVWhCTyxvQkFBa0JyQixVQUFVaUIsSUFWWixFQVVrQjs7QUFFbENLLFlBQVV0QixVQUFVWSxNQVpKLEVBWVk7QUFD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U3pELEtBSDVCLElBSUEwRCxTQUFTM0QsT0FBVCxLQUFxQjBELFNBQVMxRCxPQUo5QixJQUtBMkQsU0FBU3pELFFBQVQsS0FBc0J3RCxTQUFTeEQsUUFOakM7O0FBUUEsVUFBSTBELGVBQUosRUFBcUI7QUFDbkIsYUFBS3BDLElBQUwsQ0FBVXFDLE1BQVYsQ0FBaUI7QUFDZmxCLGtCQUFRLENBQUNnQixTQUFTOUQsU0FBVixFQUFxQjhELFNBQVM3RCxRQUE5QixDQURPO0FBRWZDLGdCQUFNNEQsU0FBUzVELElBRkE7QUFHZkMsbUJBQVMyRCxTQUFTM0QsT0FISDtBQUlmQyxpQkFBTzBELFNBQVMxRDtBQUpELFNBQWpCOztBQU9BO0FBQ0EsWUFBSTBELFNBQVN6RCxRQUFULEtBQXNCd0QsU0FBU3hELFFBQW5DLEVBQTZDO0FBQzNDLGVBQUtzQixJQUFMLENBQVVzQyxTQUFWLENBQW9CNUQsUUFBcEIsR0FBK0J5RCxTQUFTekQsUUFBeEM7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ7Ozs7bUNBQ2V3RCxRLEVBQVVDLFEsRUFBVTtBQUNqQyxVQUFNSSxjQUFjTCxTQUFTakUsS0FBVCxLQUFtQmtFLFNBQVNsRSxLQUE1QixJQUFxQ2lFLFNBQVM5RCxNQUFULEtBQW9CK0QsU0FBUy9ELE1BQXRGO0FBQ0EsVUFBSW1FLFdBQUosRUFBaUI7QUFDZixhQUFLdkMsSUFBTCxDQUFVRyxNQUFWO0FBQ0Q7QUFDRjs7Ozs7O2VBdkxrQlYsTTs7O0FBMExyQkEsT0FBT3hDLFNBQVAsR0FBbUJBLFNBQW5CO0FBQ0F3QyxPQUFPZCxZQUFQLEdBQXNCQSxZQUF0QiIsImZpbGUiOiJtYXBib3guanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cblxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vKiBnbG9iYWwgd2luZG93LCBkb2N1bWVudCwgcHJvY2VzcyAqL1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuY29uc3QgaXNCcm93c2VyID0gIShcbiAgdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmXG4gIFN0cmluZyhwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nICYmXG4gICFwcm9jZXNzLmJyb3dzZXJcbik7XG5cbmNvbnN0IG1hcGJveGdsID0gaXNCcm93c2VyID8gcmVxdWlyZSgnbWFwYm94LWdsJykgOiBudWxsO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuY29uc3QgcHJvcFR5cGVzID0ge1xuICAvLyBDcmVhdGlvbiBwYXJhbWV0ZXJzXG4gIGNvbnRhaW5lcjogUHJvcFR5cGVzLm9iamVjdCwgLyoqIFRoZSBjb250YWluZXIgdG8gaGF2ZSB0aGUgbWFwLiAqL1xuICBtYXBib3hBcGlBY2Nlc3NUb2tlbjogUHJvcFR5cGVzLnN0cmluZywgLyoqIE1hcGJveCBBUEkgYWNjZXNzIHRva2VuIGZvciBNYXBib3ggdGlsZXMvc3R5bGVzLiAqL1xuICBhdHRyaWJ1dGlvbkNvbnRyb2w6IFByb3BUeXBlcy5ib29sLCAvKiogU2hvdyBhdHRyaWJ1dGlvbiBjb250cm9sIG9yIG5vdC4gKi9cbiAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBQcm9wVHlwZXMuYm9vbCwgLyoqIFVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIGV4cG9ydCB0aGUgY2FudmFzIGFzIGEgUE5HLiAqL1xuICBvbkxvYWQ6IFByb3BUeXBlcy5mdW5jLCAvKiogVGhlIG9uTG9hZCBjYWxsYmFjayBmb3IgdGhlIG1hcCAqL1xuICBvbkVycm9yOiBQcm9wVHlwZXMuZnVuYywgLyoqIFRoZSBvbkVycm9yIGNhbGxiYWNrIGZvciB0aGUgbWFwICovXG4gIHJldXNlTWFwczogUHJvcFR5cGVzLmJvb2wsXG4gIHJldXNlTWFwOiBQcm9wVHlwZXMuYm9vbCxcbiAgdHJhbnNmb3JtUmVxdWVzdDogUHJvcFR5cGVzLmZ1bmMsIC8qKiBUaGUgdHJhbnNmb3JtUmVxdWVzdCBjYWxsYmFjayBmb3IgdGhlIG1hcCAqL1xuXG4gIG1hcFN0eWxlOiBQcm9wVHlwZXMuc3RyaW5nLCAvKiogVGhlIE1hcGJveCBzdHlsZS4gQSBzdHJpbmcgdXJsIHRvIGEgTWFwYm94R0wgc3R5bGUgKi9cbiAgdmlzaWJsZTogUHJvcFR5cGVzLmJvb2wsIC8qKiBXaGV0aGVyIHRoZSBtYXAgaXMgdmlzaWJsZSAqL1xuXG4gIC8vIE1hcCB2aWV3IHN0YXRlXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsIC8qKiBUaGUgd2lkdGggb2YgdGhlIG1hcC4gKi9cbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsIC8qKiBUaGUgaGVpZ2h0IG9mIHRoZSBtYXAuICovXG4gIGxvbmdpdHVkZTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLCAvKiogVGhlIGxvbmdpdHVkZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBtYXAuICovXG4gIGxhdGl0dWRlOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsIC8qKiBUaGUgbGF0aXR1ZGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgbWFwLiAqL1xuICB6b29tOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsIC8qKiBUaGUgdGlsZSB6b29tIGxldmVsIG9mIHRoZSBtYXAuICovXG4gIGJlYXJpbmc6IFByb3BUeXBlcy5udW1iZXIsIC8qKiBTcGVjaWZ5IHRoZSBiZWFyaW5nIG9mIHRoZSB2aWV3cG9ydCAqL1xuICBwaXRjaDogUHJvcFR5cGVzLm51bWJlciwgLyoqIFNwZWNpZnkgdGhlIHBpdGNoIG9mIHRoZSB2aWV3cG9ydCAqL1xuXG4gIC8vIE5vdGU6IE5vbi1wdWJsaWMgQVBJLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtanMvaXNzdWVzLzExMzdcbiAgYWx0aXR1ZGU6IFByb3BUeXBlcy5udW1iZXIgLyoqIEFsdGl0dWRlIG9mIHRoZSB2aWV3cG9ydCBjYW1lcmEuIERlZmF1bHQgMS41IFwic2NyZWVuIGhlaWdodHNcIiAqL1xufTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBtYXBib3hBcGlBY2Nlc3NUb2tlbjogZ2V0QWNjZXNzVG9rZW4oKSxcbiAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcbiAgYXR0cmlidXRpb25Db250cm9sOiB0cnVlLFxuICBwcmV2ZW50U3R5bGVEaWZmaW5nOiBmYWxzZSxcbiAgb25Mb2FkOiBub29wLFxuICBvbkVycm9yOiBub29wLFxuICByZXVzZU1hcHM6IGZhbHNlLFxuICByZXVzZU1hcDogZmFsc2UsXG4gIHRyYW5zZm9ybVJlcXVlc3Q6IG51bGwsXG5cbiAgbWFwU3R5bGU6ICdtYXBib3g6Ly9zdHlsZXMvbWFwYm94L2xpZ2h0LXY4JyxcbiAgdmlzaWJsZTogdHJ1ZSxcblxuICBiZWFyaW5nOiAwLFxuICBwaXRjaDogMCxcbiAgYWx0aXR1ZGU6IDEuNVxufTtcblxuLy8gVHJ5IHRvIGdldCBhY2Nlc3MgdG9rZW4gZnJvbSBVUkwsIGVudiwgbG9jYWwgc3RvcmFnZSBvciBjb25maWdcbmV4cG9ydCBmdW5jdGlvbiBnZXRBY2Nlc3NUb2tlbigpIHtcbiAgbGV0IGFjY2Vzc1Rva2VuID0gbnVsbDtcblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2F0aW9uKSB7XG4gICAgY29uc3QgbWF0Y2ggPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLm1hdGNoKC9hY2Nlc3NfdG9rZW49KFteJlxcL10qKS8pO1xuICAgIGFjY2Vzc1Rva2VuID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gIH1cblxuICBpZiAoIWFjY2Vzc1Rva2VuICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE5vdGU6IFRoaXMgZGVwZW5kcyBvbiBidW5kbGVyIHBsdWdpbnMgKGUuZy4gd2VicGFjaykgaW5tcG9ydGluZyBlbnZpcm9ubWVudCBjb3JyZWN0bHlcbiAgICBhY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuIHx8IHByb2Nlc3MuZW52Lk1hcGJveEFjY2Vzc1Rva2VuOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIH1cblxuICByZXR1cm4gYWNjZXNzVG9rZW4gfHwgbnVsbDtcbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIG1lcmdlIGRlZmF1bHRQcm9wcyBhbmQgY2hlY2sgcHJvcCB0eXBlc1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXMocHJvcHMsIGNvbXBvbmVudCA9ICdjb21wb25lbnQnKSB7XG4gIC8vIFRPRE8gLSBjaGVjayBmb3IgcHJvZHVjdGlvbiAodW5sZXNzIGRvbmUgYnkgcHJvcCB0eXBlcyBwYWNrYWdlPylcbiAgaWYgKHByb3BzLmRlYnVnKSB7XG4gICAgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgcHJvcHMsICdwcm9wJywgY29tcG9uZW50KTtcbiAgfVxufVxuXG4vLyBBIHNtYWxsIHdyYXBwZXIgY2xhc3MgZm9yIG1hcGJveC1nbFxuLy8gLSBQcm92aWRlcyBhIHByb3Agc3R5bGUgaW50ZXJmYWNlICh0aGF0IGNhbiBiZSB0cml2aWFsbHkgdXNlZCBieSBhIFJlYWN0IHdyYXBwZXIpXG4vLyAtIE1ha2VzIHN1cmUgbWFwYm94IGRvZXNuJ3QgY3Jhc2ggdW5kZXIgTm9kZVxuLy8gLSBIYW5kbGVzIG1hcCByZXVzZSAodG8gd29yayBhcm91bmQgTWFwYm94IHJlc291cmNlIGxlYWsgaXNzdWVzKVxuLy8gLSBQcm92aWRlcyBzdXBwb3J0IGZvciBzcGVjaWZ5aW5nIHRva2VucyBkdXJpbmcgZGV2ZWxvcG1lbnRcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFwYm94IHtcbiAgc3RhdGljIHN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gbWFwYm94Z2wgJiYgbWFwYm94Z2wuc3VwcG9ydGVkKCk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIGlmICghbWFwYm94Z2wpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWFwYm94IG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoIU1hcGJveC5pbml0aWFsaXplZCAmJiBjb25zb2xlLmRlYnVnKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIE1hcGJveC5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmRlYnVnKGByZWFjdC1tYXAtZ2w6IHVzaW5nIG1hcGJveC1nbCB2JHttYXBib3hnbC52ZXJzaW9ufWApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgfVxuXG4gICAgdGhpcy5wcm9wcyA9IHt9O1xuICAgIHRoaXMuX2luaXRpYWxpemUocHJvcHMpO1xuICB9XG5cbiAgZmluYWxpemUoKSB7XG4gICAgaWYgKCFtYXBib3hnbCB8fCAhdGhpcy5fbWFwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLl9kZXN0cm95KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRQcm9wcyhwcm9wcykge1xuICAgIGlmICghbWFwYm94Z2wgfHwgIXRoaXMuX21hcCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlKHRoaXMucHJvcHMsIHByb3BzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIE1hcGJveCdzIG1hcC5yZXNpemUoKSByZWFkcyBzaXplIGZyb20gRE9NLCBzbyBET00gZWxlbWVudCBtdXN0IGFscmVhZHkgYmUgcmVzaXplZFxuICAvLyBJbiBhIHN5c3RlbSBsaWtlIFJlYWN0IHdlIG11c3Qgd2FpdCB0byByZWFkIHNpemUgdW50aWwgYWZ0ZXIgcmVuZGVyXG4gIC8vIChlLmcuIHVudGlsIFwiY29tcG9uZW50RGlkVXBkYXRlXCIpXG4gIHJlc2l6ZSgpIHtcbiAgICBpZiAoIW1hcGJveGdsIHx8ICF0aGlzLl9tYXApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMuX21hcC5yZXNpemUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIEV4dGVybmFsIGFwcHMgY2FuIGFjY2VzcyBtYXAgdGhpcyB3YXlcbiAgZ2V0TWFwKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXA7XG4gIH1cblxuICAvLyBQUklWQVRFIEFQSVxuXG4gIF9jcmVhdGUocHJvcHMpIHtcbiAgICAvLyBSZXVzZSBhIHNhdmVkIG1hcCwgaWYgYXZhaWxhYmxlXG4gICAgaWYgKChwcm9wcy5yZXVzZU1hcHMgfHwgcHJvcHMucmV1c2VNYXApICYmIE1hcGJveC5zYXZlZE1hcCkge1xuICAgICAgdGhpcy5fbWFwID0gdGhpcy5tYXAgPSBNYXBib3guc2F2ZWRNYXA7XG4gICAgICAvLyBXaGVuIHJldXNpbmcgdGhlIHNhdmVkIG1hcCwgd2UgbmVlZCB0byByZXBhcmVudCB0aGUgbWFwKGNhbnZhcykgYW5kIG90aGVyIGNoaWxkIG5vZGVzXG4gICAgICAvLyBpbnRvdG8gdGhlIG5ldyBjb250YWluZXIgZnJvbSB0aGUgcHJvcHMuXG4gICAgICAvLyBTdGVwMTogcmVwYXJlbnRpbmcgY2hpbGQgbm9kZXMgZnJvbSBvbGQgY29udGFpbmVyIHRvIG5ldyBjb250YWluZXJcbiAgICAgIGNvbnN0IG9sZENvbnRhaW5lciA9IHRoaXMuX21hcC5nZXRDb250YWluZXIoKTtcbiAgICAgIGNvbnN0IG5ld0NvbnRhaW5lciA9IHByb3BzLmNvbnRhaW5lcjtcbiAgICAgIG5ld0NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdtYXBib3hnbC1tYXAnKTtcbiAgICAgIHdoaWxlIChvbGRDb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG5ld0NvbnRhaW5lci5hcHBlbmRDaGlsZChvbGRDb250YWluZXIuY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgICAvLyBTdGVwMjogcmVwbGFjZSB0aGUgaW50ZXJuYWwgY29udGFpbmVyIHdpdGggbmV3IGNvbnRhaW5lciBmcm9tIHRoZSByZWFjdCBjb21wb25lbnRcbiAgICAgIHRoaXMuX21hcC5fY29udGFpbmVyID0gbmV3Q29udGFpbmVyO1xuICAgICAgTWFwYm94LnNhdmVkTWFwID0gbnVsbDtcblxuICAgICAgLy8gVXBkYXRlIHN0eWxlXG4gICAgICBpZiAocHJvcHMubWFwU3R5bGUpIHtcbiAgICAgICAgdGhpcy5fbWFwLnNldFN0eWxlKHByb3BzLm1hcFN0eWxlKTtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETyAtIG5lZWQgdG8gY2FsbCBvbmxvYWQgYWdhaW4sIG5lZWQgdG8gdHJhY2sgd2l0aCBQcm9taXNlP1xuICAgICAgcHJvcHMub25Mb2FkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1hcE9wdGlvbnMgPSB7XG4gICAgICAgIGNvbnRhaW5lcjogcHJvcHMuY29udGFpbmVyIHx8IGRvY3VtZW50LmJvZHksXG4gICAgICAgIGNlbnRlcjogW3Byb3BzLmxvbmdpdHVkZSwgcHJvcHMubGF0aXR1ZGVdLFxuICAgICAgICB6b29tOiBwcm9wcy56b29tLFxuICAgICAgICBwaXRjaDogcHJvcHMucGl0Y2gsXG4gICAgICAgIGJlYXJpbmc6IHByb3BzLmJlYXJpbmcsXG4gICAgICAgIHN0eWxlOiBwcm9wcy5tYXBTdHlsZSxcbiAgICAgICAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICAgICAgICBhdHRyaWJ1dGlvbkNvbnRyb2w6IHByb3BzLmF0dHJpYnV0aW9uQ29udHJvbCxcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBwcm9wcy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXJcbiAgICAgIH07XG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHBhc3MgYSBudWxsIG9yIG5vLW9wIHRyYW5zZm9ybVJlcXVlc3QgZnVuY3Rpb24uXG4gICAgICBpZiAocHJvcHMudHJhbnNmb3JtUmVxdWVzdCkge1xuICAgICAgICBtYXBPcHRpb25zLnRyYW5zZm9ybVJlcXVlc3QgPSBwcm9wcy50cmFuc2Zvcm1SZXF1ZXN0O1xuICAgICAgfVxuICAgICAgdGhpcy5fbWFwID0gdGhpcy5tYXAgPSBuZXcgbWFwYm94Z2wuTWFwKG1hcE9wdGlvbnMpO1xuICAgICAgLy8gQXR0YWNoIG9wdGlvbmFsIG9uTG9hZCBmdW5jdGlvblxuICAgICAgdGhpcy5tYXAub25jZSgnbG9hZCcsIHByb3BzLm9uTG9hZCk7XG4gICAgICB0aGlzLm1hcC5vbignZXJyb3InLCBwcm9wcy5vbkVycm9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIF9kZXN0cm95KCkge1xuICAgIGlmICghTWFwYm94LnNhdmVkTWFwKSB7XG4gICAgICBNYXBib3guc2F2ZWRNYXAgPSB0aGlzLl9tYXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21hcC5yZW1vdmUoKTtcbiAgICB9XG4gIH1cblxuICBfaW5pdGlhbGl6ZShwcm9wcykge1xuICAgIHByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFByb3BzLCBwcm9wcyk7XG4gICAgY2hlY2tQcm9wVHlwZXMocHJvcHMsICdNYXBib3gnKTtcblxuICAgIC8vIE1ha2UgZW1wdHkgc3RyaW5nIHBpY2sgdXAgZGVmYXVsdCBwcm9wXG4gICAgdGhpcy5hY2Nlc3NUb2tlbiA9IHByb3BzLm1hcGJveEFwaUFjY2Vzc1Rva2VuIHx8IGRlZmF1bHRQcm9wcy5tYXBib3hBcGlBY2Nlc3NUb2tlbjtcblxuICAgIC8vIENyZWF0aW9uIG9ubHkgcHJvcHNcbiAgICBpZiAobWFwYm94Z2wpIHtcbiAgICAgIGlmICghdGhpcy5hY2Nlc3NUb2tlbikge1xuICAgICAgICBtYXBib3hnbC5hY2Nlc3NUb2tlbiA9ICduby10b2tlbic7IC8vIFByZXZlbnRzIG1hcGJveCBmcm9tIHRocm93aW5nXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXBib3hnbC5hY2Nlc3NUb2tlbiA9IHRoaXMuYWNjZXNzVG9rZW47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fY3JlYXRlKHByb3BzKTtcblxuICAgIC8vIERpc2FibGUgb3V0bGluZSBzdHlsZVxuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMubWFwLmdldENhbnZhcygpO1xuICAgIGlmIChjYW52YXMpIHtcbiAgICAgIGNhbnZhcy5zdHlsZS5vdXRsaW5lID0gJ25vbmUnO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZU1hcFZpZXdwb3J0KHt9LCBwcm9wcyk7XG4gICAgdGhpcy5fdXBkYXRlTWFwU2l6ZSh7fSwgcHJvcHMpO1xuXG4gICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB9XG5cbiAgX3VwZGF0ZShvbGRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICBuZXdQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIG5ld1Byb3BzKTtcbiAgICBjaGVja1Byb3BUeXBlcyhuZXdQcm9wcywgJ01hcGJveCcpO1xuXG4gICAgdGhpcy5fdXBkYXRlTWFwVmlld3BvcnQob2xkUHJvcHMsIG5ld1Byb3BzKTtcbiAgICB0aGlzLl91cGRhdGVNYXBTaXplKG9sZFByb3BzLCBuZXdQcm9wcyk7XG5cbiAgICB0aGlzLnByb3BzID0gbmV3UHJvcHM7XG4gIH1cblxuICBfdXBkYXRlTWFwVmlld3BvcnQob2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgY29uc3Qgdmlld3BvcnRDaGFuZ2VkID1cbiAgICAgIG5ld1Byb3BzLmxhdGl0dWRlICE9PSBvbGRQcm9wcy5sYXRpdHVkZSB8fFxuICAgICAgbmV3UHJvcHMubG9uZ2l0dWRlICE9PSBvbGRQcm9wcy5sb25naXR1ZGUgfHxcbiAgICAgIG5ld1Byb3BzLnpvb20gIT09IG9sZFByb3BzLnpvb20gfHxcbiAgICAgIG5ld1Byb3BzLnBpdGNoICE9PSBvbGRQcm9wcy5waXRjaCB8fFxuICAgICAgbmV3UHJvcHMuYmVhcmluZyAhPT0gb2xkUHJvcHMuYmVhcmluZyB8fFxuICAgICAgbmV3UHJvcHMuYWx0aXR1ZGUgIT09IG9sZFByb3BzLmFsdGl0dWRlO1xuXG4gICAgaWYgKHZpZXdwb3J0Q2hhbmdlZCkge1xuICAgICAgdGhpcy5fbWFwLmp1bXBUbyh7XG4gICAgICAgIGNlbnRlcjogW25ld1Byb3BzLmxvbmdpdHVkZSwgbmV3UHJvcHMubGF0aXR1ZGVdLFxuICAgICAgICB6b29tOiBuZXdQcm9wcy56b29tLFxuICAgICAgICBiZWFyaW5nOiBuZXdQcm9wcy5iZWFyaW5nLFxuICAgICAgICBwaXRjaDogbmV3UHJvcHMucGl0Y2hcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUT0RPIC0ganVtcFRvIGRvZXNuJ3QgaGFuZGxlIGFsdGl0dWRlXG4gICAgICBpZiAobmV3UHJvcHMuYWx0aXR1ZGUgIT09IG9sZFByb3BzLmFsdGl0dWRlKSB7XG4gICAgICAgIHRoaXMuX21hcC50cmFuc2Zvcm0uYWx0aXR1ZGUgPSBuZXdQcm9wcy5hbHRpdHVkZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBOb3RlOiBuZWVkcyB0byBiZSBjYWxsZWQgYWZ0ZXIgcmVuZGVyIChlLmcuIGluIGNvbXBvbmVudERpZFVwZGF0ZSlcbiAgX3VwZGF0ZU1hcFNpemUob2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgY29uc3Qgc2l6ZUNoYW5nZWQgPSBvbGRQcm9wcy53aWR0aCAhPT0gbmV3UHJvcHMud2lkdGggfHwgb2xkUHJvcHMuaGVpZ2h0ICE9PSBuZXdQcm9wcy5oZWlnaHQ7XG4gICAgaWYgKHNpemVDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9tYXAucmVzaXplKCk7XG4gICAgfVxuICB9XG59XG5cbk1hcGJveC5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XG5NYXBib3guZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuIl19